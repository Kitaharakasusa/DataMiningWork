import numpy as npimport mathc=[] #所有的类别def readfile():    rf = open("iris.txt", "r", encoding="utf-8")    allvector = list()    for line in rf:        vec=line.strip().split(",")        lable=vec[-1]        if lable.strip() not in c:            c.append(lable.strip())        allvector.append(vec)    print(allvector)    print(c)    return allvector    # for line in rf:    #     vecotor = line.split(",")[0:-1]    #     # print(vecotor)    #     floatlis = []    #     for str in vecotor:    #         floatlis.append(float(str))    #     allvector.append(floatlis)    # np1 = np.array(allvector)    # return np1def getpurity(ni,n):    maxnow=0    maxindex=0    for i in range(len(ni)):        if ni[i]/n > maxnow:            maxnow=ni[i]/n            maxindex=i    return maxnow,maxindex# yj是每一组数据的labledef CaculatePciDy(Nvi,Nv):    nowsum=0    for j in range(len(Nv)):        nowsum+=Nv[j]    return Nvi/nowsumdef CaculatePciDn(Nvi,Nv,nii,ni):    nowsum=0    for j in range(len(Nv)):        nowsum+=(ni[j]-Nv[j])    return (nii-Nvi)/nowsumdef PciD(Cindex,D):  #计算P(ci|D)    csum=0    for i in range(len(D)):        if(D[i][-1]==c[Cindex]):            csum+=1    return csum/len(D)def HD(D):    res = 0    for i in range(len(c)):        a = PciD(i, D)        res -= (a * math.log(a, 2))    return resdef Gain(D,Dy,Dn):    n=len(D)    ny=len(Dy)    nn=len(Dn)    res=HD(D)-((ny/n)*HD(Dy)+(nn/n)*HD(Dn))    return resdef EVALUATE_NUMERIC_ATTRIBUTE9(D,Xj):    #这里的Xj就是属性的下标    Nv=[0]*len(c)    D.sort(key=lambda d:d[Xj])    M=set() #set of midpoint    ni=[0]*len(c)   #ni<-0    for i in range(len(c)):        for j in range(len(D)-1):            if D[j][-1]==c[i]:                ni[i]+=1            if D[j+1][Xj]!=D[j][Xj]:                v=(D[j+1][Xj]+D[j][Xj])/2                M.add(v)            for x in range(len(c)):                Nv[x]=ni[i]        if D[len(D)-1][-1]==c[i]:            ni[i]+=1    vxing=0    scorexing=0    for v in M:        PciDy=[0]*len(c)        PciDn=[0]*len(c)        for i in range(len(c)):            PciDy=CaculatePciDy(Nv[i],Nv)            PciDn=CaculatePciDn(Nv[i],Nv,ni[i],ni)        NowDy=[]        NowDn=[]        for index in range(len(D)):            if(D[index][Xj]<=v):                NowDy.append(D[index])            else:                NowDn.append(D[index])        scoreXxyv=Gain(D,Dy=NowDy,Dn=NowDn)        if scoreXxyv>scorexing:            vxing=v            scorexing=scoreXxyv    return vxing,scorexingdef Decision_tree(D,yita,pi):    n=D.shape[0] #patition size    ni=[0]*len(c)    for i in range(len(c)):       for j in range(n):           if D[j][-1]==c[i]: #yj=ci size of class ci                n[i]+=1    putityD,index=getpurity(ni,n)    if n<=yita or putityD>=pi:        cxing=c[index] #majority class    splitponit=0 #这个点是个具体的值    splitponitindex=0 #这个参数记录具体是哪个属性    scorexing=0    for i in range(len(D[0])-1):        v,score=EVALUATE_NUMERIC_ATTRIBUTE9(D,i)        if score>scorexing:            splitponit=v            splitponitindex=i            scorexing=score    Dy=[]    Dn=[]    #// partition D into DY and DN using split point∗, and call recursively    for i in range(len(D)):        if D[i][splitponitindex]<=splitponit:            Dy.append(D[i])        else:            Dn.append(D[i])if __name__=="__main__":    # readfile()    # a=list()    # a.append(["a","1"])    # a.append(["b","2"])    #    # a.sort(key=lambda d:d[0],reverse=True)    # print(a[-1])